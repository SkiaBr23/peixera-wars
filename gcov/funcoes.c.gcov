        -:    0:Source:funcoes.c
        -:    0:Programs:4
        -:    1:/*! \file funcoes.c
        -:    2:	\brief Módulo para gerenciar as estruturas */
        -:    3:
        -:    4:/*
        -:    5:PROJETO
        -:    6:Nome: MAXIMILLIAN FAN XAVIER, OTÁVIO ALVES DIAS, RAFAEL DIAS DA COSTA, TÚLIO ABNER DE LIMA
        -:    7:Matrícula: 12/0153271, 12/0131480, 12/0133253, 12/0137194
        -:    8:Curso: Engenharia de Computação
        -:    9:Disciplina: Métodos de Programação
        -:   10:Turma: A
        -:   11:Prof: Jan Mendonça
        -:   12:*/
        -:   13:
        -:   14:/*INCLUSÃO DAS BIBLIOTECAS*/
        -:   15:#include <stdio.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:#include <strings.h>
        -:   19:#include "estruturas.h"
        -:   20:#include "engine.h"
        -:   21:
        -:   22:/*	--------------------FUNÇÕES DE CRIAÇÃO--------------------	*/
        -:   23:
        -:   24:/***************************************************************************/
        -:   25:/**
        -:   26:* \fn CabecaGeral* CriaCabecaGeral ()
        -:   27:*
        -:   28:* \brief Aloca a estrutura controladora do game e faz com que seus ponteiros internos para as estruturas do game apontem para NULL.
        -:   29:*
        -:   30:* void - Nenhum parâmetro enviada para a função.
        -:   31:*
        -:   32:* \return Retorna a estrutura alocada com os ponteiros internos apontando para NULL.
        -:   33:* 
        -:   34:* Assertiva de entrada
        -:   35:*
        -:   36:* Não possui assertivas de entrada.
        -:   37:***************************************************************************/
        -:   38:
        -:   39:/*
        -:   40:Função responsável para criação de estruturas do tipo CabecaGeral.
        -:   41:REQUISITO: Ter memória suficiente para alocação.
        -:   42:HIPOTESE: A função deve alocar e retornar um ponteiro do tipo CabecaGeral com ponteiros character=NULL e castle=NULL.
        -:   43:ASSERTIVAS DE ENTRADA: Não há.
        -:   44:ASSERTIVAS DE SAÍDA: O ponteiro novo deve ser diferente de nulo para ser retornado, caso contrário, retorna-se NULL.
        -:   45:INTERFACE EXPLÍCITA: O tipo de retorno CabecaGeral*.
        -:   46:INTERFACE IMPLÍCITA: CabecaGeral* novo, novo->character, novo->castle.
        -:   47:*/
        5:   48:CabecaGeral* CriaCabecaGeral () {
        5:   49:	CabecaGeral * novo = (CabecaGeral*) malloc (sizeof(CabecaGeral));	/*Aloca um espaço de memória do tipo CabecaGeral*/
        5:   50:	novo->character = NULL;	/*Associa valores de NULL aos ponteiros e character e castle*/
        5:   51:	novo->castle = NULL;
        -:   52:
        5:   53:	if (novo != NULL) {	/*Verificação de retorno. Analisa se o espaço se memória foi alocado*/
        5:   54:		return novo;	/*Caso tenha sido, retorna a cabeça criada*/
        -:   55:	} else {
    #####:   56:		return NULL;	/*Caso contrário, retorna NULL*/
        -:   57:	}
        -:   58:}
        -:   59:
        -:   60:/***************************************************************************/
        -:   61:/**
        -:   62:* \fn CabecaPFilas* CriaCabecaPFilas ()
        -:   63:*
        -:   64:* \brief Aloca a estrutura que contém as duas listas de personagens do game (player e cpu), fazendo com que seus ponteiros internos apontem para * NULL.
        -:   65:*
        -:   66:* void - Nenhum parâmetro enviada para a função.
        -:   67:*
        -:   68:* \return Retorna a estrutura alocada com os ponteiros internos apontando para NULL.
        -:   69:* 
        -:   70:* Assertiva de entrada
        -:   71:*
        -:   72:* Não possui assertivas de entrada.
        -:   73:***************************************************************************/
        -:   74:
        -:   75:/*
        -:   76:Função responsável para criação de estruturas do tipo CabecaPFilas.
        -:   77:REQUISITO: Ter memória suficiente para alocação.
        -:   78:HIPOTESE: A função deve alocar e retornar um ponteiro do tipo CabecaPFilas com ponteiros player e cpu iguais a NULL.
        -:   79:ASSERTIVAS DE ENTRADA: Não há.
        -:   80:ASSERTIVAS DE SAÍDA: O ponteiro novo deve ser diferente de nulo para ser retornado, caso contrário, retorna-se NULL.
        -:   81:INTERFACE EXPLÍCITA: O tipo de retorno CabecaGeral*.
        -:   82:INTERFACE IMPLÍCITA: CabecaPFilas* novo, novo->player, novo->cpu.
        -:   83:*/
        3:   84:CabecaPFilas* CriaCabecaPFilas () {
        3:   85:	CabecaPFilas * novo = (CabecaPFilas*) malloc (sizeof(CabecaPFilas));	/*Aloca um espaço de memoria do tipo CabecaPFilas*/
        3:   86:	novo->player = NULL;	/*Associa valores de NULL aos ponteiros de player e cpu*/
        3:   87:	novo->cpu = NULL;
        -:   88:
        3:   89:	if (novo != NULL) {	/*Verificação de retorno. Analisa se o espaço se memória foi alocado*/
        3:   90:		return novo;	/*Caso tenha sido, retorna a cabeça criada*/
        -:   91:	} else {
    #####:   92:		return NULL;	/*Caso contrário, retorna NULL*/
        -:   93:	}
        -:   94:}
        -:   95:
        -:   96:/***************************************************************************/
        -:   97:/**
        -:   98:* \fn Castelo* CriaCastelo (int novawave,int valor)
        -:   99:*
        -:  100:* \brief Aloca a estrutura que contém os ponteiros para cada edifício do game e faz com que esses ponteiros apontem para NULL.
        -:  101:*
        -:  102:* @param novawave - determina o valor inicial
        -:  103:* @param valor - informa a quantidade de ouro
        -:  104:*
        -:  105:* \return Retorna o a estrutura alocada com os ponteiros internos apontando para NULL.
        -:  106:* 
        -:  107:* Assertiva de entrada
        -:  108:*
        -:  109:* Não possui assertivas de entrada.
        -:  110:***************************************************************************/
        -:  111:
        -:  112:/*
        -:  113:Função responsável para criação de estruturas do tipo Castelo.
        -:  114:REQUISITO: Ter memória suficiente para alocação.
        -:  115:HIPOTESE: A função deve alocar e retornar um ponteiro Castelo com ponteiros quartel,campodetiro,casadaslancas e comercio iguais a NULL. O atributo ouro deve ser incializado com 100.
        -:  116:ASSERTIVAS DE ENTRADA: Não há.
        -:  117:ASSERTIVAS DE SAÍDA: O ponteiro novo deve ser diferente de nulo para ser retornado, caso contrário, retorna-se NULL.
        -:  118:INTERFACE EXPLÍCITA: O tipo de retorno Castelo*.
        -:  119:INTERFACE IMPLÍCITA: Castelo * novo, novo->quartel, novo->campodetiro, novo->casadaslancas, novo->comercio, novo->ouro
        -:  120:*/
        3:  121:Castelo* CriaCastelo (int novawave,int valor) {
        3:  122:	Castelo * novo = (Castelo*) malloc (sizeof(Castelo));	/*Aloca um espaço de memoria do tipo Castelo*/
        3:  123:	novo->quartel = NULL;	/*Associa valores de NULL aos ponteiros de quartel,campodetiro,casadaslancas e comercio*/
        3:  124:	novo->campodetiro = NULL;
        3:  125:	novo->casadaslancas = NULL;
        3:  126:	novo->comercio = NULL;
        3:  127:	if(novawave==1){	/*Se o jogo começar da primeira horda, seta o valor inicial de ouro para 100*/
        1:  128:		novo->ouro = 100;	/*Seta o valor inicial de ouro*/
        -:  129:	}else{
        2:  130:		novo->ouro = valor;	/*Se o jogo começar de uma horda carregada, atualiza o valor*/
        -:  131:	}
        3:  132:	if (novo != NULL) {	/*Verificação de retorno. Analisa se o espaço se memória foi alocado*/
        3:  133:		return novo;	/*Caso tenha sido, retorna a cabeça criada*/
        -:  134:	} else {
    #####:  135:		return NULL;	/*Caso contrário, retorna NULL*/
        -:  136:	}
        -:  137:}
        -:  138:
        -:  139:/***************************************************************************/
        -:  140:/**
        -:  141:* \fn Unidade* CriaUnidade ()
        -:  142:*
        -:  143:* \brief Inicializa uma estrutura de Unidade com o valor NULL.
        -:  144:*
        -:  145:* void - Nenhum parâmetro enviada para a função.
        -:  146:*
        -:  147:* \return Retorna o valor NULL para o ponteiro do tipo Unidade.
        -:  148:* 
        -:  149:* Assertiva de entrada
        -:  150:*
        -:  151:* Não possui assertivas de entrada.
        -:  152:***************************************************************************/
        -:  153:
        -:  154:/*
        -:  155:Função responsável para criação de estruturas do tipo Unidade.
        -:  156:REQUISITO: Ter memória suficiente para alocação.
        -:  157:HIPOTESE: A função deve retornar um ponteiro de Unidade igual a NULL.
        -:  158:ASSERTIVAS DE ENTRADA: Não há.
        -:  159:ASSERTIVAS DE SAÍDA: Não há.
        -:  160:INTERFACE EXPLÍCITA: O tipo de retorno Unidade*.
        -:  161:INTERFACE IMPLÍCITA: O retorno ser igual a NULL.
        -:  162:*/
        6:  163:Unidade* CriaUnidade () {
        6:  164:	return NULL;	/*A função deve apenas retornar NULL*/
        -:  165:}
        -:  166:
        -:  167:/***************************************************************************/
        -:  168:/**
        -:  169:* \fn Edificio* CriaEdificio ()
        -:  170:*
        -:  171:* \brief Inicializa a estrutura Edificio com o valor NULL.
        -:  172:*
        -:  173:* void - Nenhum parâmetro enviada para a função.
        -:  174:*
        -:  175:* \return Retorna o valor NULL para o ponteiro do tipo Edificio.
        -:  176:* 
        -:  177:* Assertiva de entrada
        -:  178:*
        -:  179:* Não possui assertivas de entrada.
        -:  180:***************************************************************************/
        -:  181:
        -:  182:/*
        -:  183:Função responsável para criação de estruturas do tipo Edificio.
        -:  184:REQUISITO: Ter memória suficiente para alocação.
        -:  185:HIPOTESE: A função deve retornar um ponteiro de Edificio igual a NULL.
        -:  186:ASSERTIVAS DE ENTRADA: Não há.
        -:  187:ASSERTIVAS DE SAÍDA: Não há.
        -:  188:INTERFACE EXPLÍCITA: O tipo de retorno Edificio*.
        -:  189:INTERFACE IMPLÍCITA: O retorno ser igual a NULL.
        -:  190:*/
        9:  191:Edificio* CriaEdificio () {
        9:  192:	return NULL;	/*A função deve apenas retornar NULL*/
        -:  193:}
        -:  194:
        -:  195:/***************************************************************************/
        -:  196:/**
        -:  197:* \fn Comercio* CriaComercio ()
        -:  198:*
        -:  199:* \brief Inicializa a estrutura Comércio com o valor NULL.
        -:  200:*
        -:  201:* void - Nenhum parâmetro enviada para a função.
        -:  202:*
        -:  203:* \return Retorna o valor NULL para o ponteiro do tipo Comercio.
        -:  204:* 
        -:  205:* Assertiva de entrada
        -:  206:*
        -:  207:* Não possui assertivas de entrada.
        -:  208:***************************************************************************/
        -:  209:
        -:  210:/*
        -:  211:Função responsável para criação de estruturas do tipo Comercio.
        -:  212:REQUISITO: Ter memória suficiente para alocação.
        -:  213:HIPOTESE: A função deve retornar um ponteiro Comercio igual a NULL.
        -:  214:ASSERTIVAS DE ENTRADA: Não há.
        -:  215:ASSERTIVAS DE SAÍDA: Não há.
        -:  216:INTERFACE EXPLÍCITA: O tipo de retorno Comercio*.
        -:  217:INTERFACE IMPLÍCITA: O retorno ser igual a NULL.
        -:  218:*/
        3:  219:Comercio* CriaComercio () {
        3:  220:	return NULL;	/*A função deve apenas retornar NULL*/
        -:  221:}
        -:  222:
        -:  223:/*	--------------------FUNÇÕES QUE ANALISAM SE UMA LISTA ESTÁ VAZIA--------------------	*/
        -:  224:
        -:  225:/***************************************************************************/
        -:  226:/**
        -:  227:* \fn int CabecaGeralVazia(CabecaGeral* lis)
        -:  228:*
        -:  229:* \brief Verifica se a estrutura controladora do game é nula ou não.
        -:  230:*
        -:  231:* @param lis - ponteiro para a estrutura controladora
        -:  232:*
        -:  233:* \return Retorna o valor inteiro 1 caso a estrutura seja nula, ou 0 caso não seja.
        -:  234:* 
        -:  235:* Assertiva de entrada
        -:  236:*
        -:  237:* A estrutura enviada precisa ter sido declarada.
        -:  238:***************************************************************************/
        -:  239:
        -:  240:/*
        -:  241:Função que verifica se uma lista está vazia
        -:  242:REQUISITO: Ter um ponteiro de CabecaGeral alocado na memória.
        -:  243:HIPOTESE: A função deve retornar 1 caso o ponteiro seja igual a NULL(lista vazia) e 0 caso contrário(lista não vazia).
        -:  244:ASSERTIVAS DE ENTRADA: Estrutura enviada ter sido declarada e há a necessidade de um ponteiro de CabecaGeral alocado.
        -:  245:ASSERTIVAS DE SAÍDA: Verficia se é vazia, se for, retorna 1 e, caso contrario, retorna 0.
        -:  246:INTERFACE EXPLÍCITA: O tipo de retorno "int" e o parâmetro de entrada do tipo CabecaGeral*.
        -:  247:INTERFACE IMPLÍCITA: A verificação de retorno 1 ou 0.
        -:  248:*/
       11:  249:int CabecaGeralVazia(CabecaGeral* lis){
       11:  250:	if(lis==NULL){	/*Se a lista for vazia, retorna 1, caso contrario, retorna 0*/
    #####:  251:		return 1;
        -:  252:	}else{
       11:  253:		return 0;
        -:  254:	}
        -:  255:}
        -:  256:
        -:  257:/***************************************************************************/
        -:  258:/**
        -:  259:* \fn int CabecaPFilasVazia(CabecaPFilas* lis)
        -:  260:*
        -:  261:* \brief Verifica se a estrutura que contém as listas de personagens é nula ou não.
        -:  262:*
        -:  263:* @param lis - ponteiro para a estrutura dos personagens
        -:  264:*
        -:  265:* \return Retorna o valor inteiro 1 caso a estrutura seja nula, ou 0 caso não seja.
        -:  266:* 
        -:  267:* Assertiva de entrada
        -:  268:*
        -:  269:* A estrutura enviada para a função precisa ter sido declarada.
        -:  270:***************************************************************************/
        -:  271:
        -:  272:/*
        -:  273:Função que verifica se uma lista está vazia.
        -:  274:REQUISITO: Ter um ponteiro de CabecaPFilas alocado na memória.
        -:  275:HIPOTESE: A função deve retornar 1 caso o ponteiro seja igual a NULL(lista vazia) e 0 caso contrário(lista não vazia).
        -:  276:ASSERTIVAS DE ENTRADA: Estrutura enviada para a função necessita ter sido declarada e alocada.
        -:  277:ASSERTIVAS DE SAÍDA: Verficia se é vazia, se for, retorna 1 e, caso contrario, retorna 0.
        -:  278:INTERFACE EXPLÍCITA: O tipo de retorno "int" e o parâmetro de entrada do tipo CabecaPFilas*.
        -:  279:INTERFACE IMPLÍCITA: A verificação de retorno 1 ou 0.
        -:  280:*/
        3:  281:int CabecaPFilasVazia(CabecaPFilas* lis) {
        3:  282:	if(lis==NULL){	/*Se a lista for vazia, retorna 1, caso contrario, retorna 0*/
    #####:  283:		return 1;
        -:  284:	}else{
        3:  285:		return 0;
        -:  286:	}
        -:  287:}
        -:  288:
        -:  289:/***************************************************************************/
        -:  290:/**
        -:  291:* \fn int CasteloVazia(Castelo* lis)
        -:  292:*
        -:  293:* \brief Verifica se a estrutura que contém os edifícios é nula ou não.
        -:  294:*
        -:  295:* @param lis - ponteiro para a estrutura que contém os edifícios
        -:  296:*
        -:  297:* \return Retorna o valor inteiro 1 caso a estrutura seja nula, ou 0 caso não seja.
        -:  298:* 
        -:  299:* Assertiva de entrada
        -:  300:*
        -:  301:* A estrutura enviada para a função precisa ter sido declarada.
        -:  302:***************************************************************************/
        -:  303:
        -:  304:/*
        -:  305:Função que verifica se uma lista está vazia.
        -:  306:REQUISITO: Ter um ponteiro de Castelo alocado na memória.
        -:  307:HIPOTESE: A função deve retornar 1 caso o ponteiro seja igual a NULL(lista vazia) e 0 caso contrário(lista não vazia).
        -:  308:ASSERTIVAS DE ENTRADA: Estrutura enviada para a função necessita ter sido declarada e alocada.
        -:  309:ASSERTIVAS DE SAÍDA: Verficia se é vazia, se for, retorna 1 e, caso contrario, retorna 0.
        -:  310:INTERFACE EXPLÍCITA: O tipo de retorno "int" e o parâmetro de entrada do tipo Cstelo*.
        -:  311:INTERFACE IMPLÍCITA: A verificação de retorno 1 ou 0.
        -:  312:*/
        3:  313:int CasteloVazia(Castelo* lis) {
        3:  314:	if(lis==NULL){	/*Se a lista for vazia, retorna 1, caso contrario, retorna 0*/
    #####:  315:		return 1;
        -:  316:	}else{
        3:  317:		return 0;
        -:  318:	}
        -:  319:}
        -:  320:
        -:  321:/***************************************************************************/
        -:  322:/**
        -:  323:* \fn int UnidadeVazia(Unidade* lis)
        -:  324:*
        -:  325:* \brief Verifica se a estrutura de Unidade é nula ou não.
        -:  326:*
        -:  327:* @param lis - ponteiro para a estrutura Unidade.
        -:  328:*
        -:  329:* \return Retorna o valor inteiro 1 caso a estrutura seja nula, ou 0 caso contrário.
        -:  330:* 
        -:  331:* Assertiva de entrada
        -:  332:*
        -:  333:* A estrutura de Unidade enviada para a função precisa ter sido declarada corretamente.
        -:  334:***************************************************************************/
        -:  335:
        -:  336:/*
        -:  337:Função que verifica se uma lista está vazia.
        -:  338:REQUISITO: Ter um ponteiro de Unidade alocado na memória.
        -:  339:HIPOTESE: A função deve retornar 1 caso o ponteiro seja igual a NULL(lista vazia) e 0 caso contrário(lista não vazia).
        -:  340:ASSERTIVAS DE ENTRADA: Estrutura enviada para a função necessita ter sido declarada e alocada.
        -:  341:ASSERTIVAS DE SAÍDA: Verficia se é vazia, se for, retorna 1 e, caso contrario, retorna 0.
        -:  342:INTERFACE EXPLÍCITA: O tipo de retorno "int" e o parâmetro de entrada do tipo Unidade*.
        -:  343:INTERFACE IMPLÍCITA: A verificação de retorno 1 ou 0.
        -:  344:*/
      326:  345:int UnidadeVazia(Unidade* lis) {
      326:  346:	if(lis==NULL){	/*Se a lista for vazia, retorna 1, caso contrario, retorna 0*/
       53:  347:		return 1;
        -:  348:	}else{
      273:  349:		return 0;
        -:  350:	}
        -:  351:}
        -:  352:
        -:  353:/***************************************************************************/
        -:  354:/**
        -:  355:* \fn int ComercioVazia(Comercio* lis)
        -:  356:*
        -:  357:* \brief Verifica se a estrutura Comercio está alocada ou não.
        -:  358:*
        -:  359:* @param lis - ponteiro para a estrutura Comercio (geradora de recursos).
        -:  360:*
        -:  361:* \return Retorna o valor inteiro 1 caso a estrutura seja nula, ou 0 caso contrário.
        -:  362:* 
        -:  363:* Assertiva de entrada
        -:  364:*
        -:  365:* A estrutura de Comercio precisa ter sido declarada.
        -:  366:***************************************************************************/
        -:  367:
        -:  368:/*
        -:  369:Função que verifica se uma lista está vazia.
        -:  370:REQUISITO: Ter um ponteiro de Comercio alocado na memória.
        -:  371:HIPOTESE: A função deve retornar 1 caso o ponteiro seja igual a NULL(lista vazia) e 0 caso contrário(lista não vazia).
        -:  372:ASSERTIVAS DE ENTRADA: Estrutura enviada para a função necessita ter sido declarada e alocada.
        -:  373:ASSERTIVAS DE SAÍDA: Verficia se é vazia, se for, retorna 1 e, caso contrario, retorna 0.
        -:  374:INTERFACE EXPLÍCITA: O tipo de retorno "int" e o parâmetro de entrada do tipo Comercio*.
        -:  375:INTERFACE IMPLÍCITA: A verificação de retorno 1 ou 0.
        -:  376:*/
        4:  377:int ComercioVazia(Comercio* lis) {
        4:  378:	if(lis==NULL){	/*Se a lista for vazia, retorna 1, caso contrario, retorna 0*/
        2:  379:		return 1;
        -:  380:	}else{
        2:  381:		return 0;
        -:  382:	}
        -:  383:}
        -:  384:
        -:  385:/***************************************************************************/
        -:  386:/**
        -:  387:* \fn int EdificioVazia(Edificio* lis)
        -:  388:*
        -:  389:* \brief Verifica se a estrutura Edificio é nula ou não.
        -:  390:*
        -:  391:* @param lis - ponteiro para a estrutura Edificio.
        -:  392:*
        -:  393:* \return Retorna o valor inteiro 1 caso a estrutura seja nula, ou 0 caso contrário.
        -:  394:* 
        -:  395:* Assertiva de entrada
        -:  396:*
        -:  397:* A estrutura de Edificio enviada para a função precisa ter sido declarada.
        -:  398:***************************************************************************/
        -:  399:
        -:  400:/*
        -:  401:Função que verifica se uma lista está vazia.
        -:  402:REQUISITO: Ter um ponteiro de Edificio alocado na memória.
        -:  403:HIPOTESE: A função deve retornar 1 caso o ponteiro seja igual a NULL(lista vazia) e 0 caso contrário(lista não vazia).
        -:  404:ASSERTIVAS DE SAÍDA: Verficia se é vazia, se for, retorna 1 e, caso contrario, retorna 0.
        -:  405:INTERFACE EXPLÍCITA: O tipo de retorno "int" e o parâmetro de entrada do tipo Edificio*.
        -:  406:INTERFACE IMPLÍCITA: A verificação de retorno 1 ou 0.
        -:  407:*/
       13:  408:int EdificioVazia(Edificio* lis) {
       13:  409:	if(lis==NULL){	/*Se a lista for vazia, retorna 1, caso contrario, retorna 0*/
        7:  410:		return 1;
        -:  411:	}else{
        6:  412:		return 0;
        -:  413:	}
        -:  414:}
        -:  415:
        -:  416:/*	--------------------FUNÇÕES DE INSERÇÃO--------------------	*/
        -:  417:
        -:  418:/***************************************************************************/
        -:  419:/**
        -:  420:* \fn Unidade* InserirUnidadeFinal(Unidade* lis,int vida,int dano,float esquiva,int nivel,int classe)
        -:  421:*
        -:  422:* \brief Realiza a inserção de um personagem na lista de personagens do game sempre a última posição da lista.
        -:  423:*
        -:  424:* @param lis - ponteiro para a estrutura Unidade (lista de personagens)
        -:  425:* @param vida - valor inteiro que representa a vida do personagem.
        -:  426:* @param dano - valor inteiro que representa o dano causado por esse personagem.
        -:  427:* @param esquiva - valor decimal que representa a capacidade de esquiva do personagem.
        -:  428:* @param nivel - valor inteiro que representa o nível do personagem.
        -:  429:* @param classe - valor inteiro que representa qual o tipo do personagem.
        -:  430:*
        -:  431:* \return Retorna a lista de personagens atualizada.
        -:  432:* 
        -:  433:* Assertiva de entrada
        -:  434:*
        -:  435:* A estrutura Unidade enviada para a função precisa ter sido declarada.
        -:  436:* Os tipos de cada parâmetros precisam estar de acordo.
        -:  437:***************************************************************************/
        -:  438:
        -:  439:/*
        -:  440:Função de inserção no fim da lista Unidade.
        -:  441:REQUISITOS: Ter um ponteiro de Unidade alocado e enviar informações positivas como argumento da função.
        -:  442:HIPÓTESES: A função deve inserir um novo nó no fim da lista de forma que o ponteiro de próximo seja igual a NULL e o ponteiro de anterior seja igual ao antigo nodo final.
        -:  443:ASSERTIVAS DE ENTRADA: Estrutura enviada para a função necessita ter sido declarada e alocada e os atributos devem estar de acordo com seus tipos.
        -:  444:ASSERTIVAS DE SAÍDA: Se os valores enviados estiverem dentro da faixa aceita, realizam-se as operações de inserção e a lista atulizada é retornada, caso contrário, retorna-se a lista sem efetuar operações.
        -:  445:INTERFACE EXPLÍCITA: O tipo de retorno Unidade* e os parâmetros de entrada Unidade* lis,int vida,int dano,float esquiva,int nivel,int classe.
        -:  446:INTERFACE IMPLÍCITA: Alocação e atribuição de valores para a célula "novo", a inserção do elemento na lista e as verificações de entrada e saída.
        -:  447:*/
       85:  448:Unidade* InserirUnidadeFinal(Unidade* lis,int vida,int dano,float esquiva,int nivel,int classe){
       85:  449:	Unidade* novo = (Unidade*)malloc(sizeof(Unidade));	/*aloca uma celula nova do tipo Unidade*/
       85:  450:	Unidade* aux = lis;	/*ponteiro auxiliar do tipo Unidade recebe a lista do parâmetro de entrada*/
        -:  451:	
       85:  452:	novo->vida = vida;	/*coloca as informações em uma celula auxiliar*/
       85:  453:	novo->dano = dano;
       85:  454:	novo->esquiva = esquiva;
       85:  455:	novo->nivel = nivel;
       85:  456:	novo->classe = classe;
       85:  457:	novo->prox = NULL;	/*nula-se o ponteiro de próximo já que a célula será sempre inserida no fim da lista*/
        -:  458:	
       85:  459:	if((classe>=1 && classe<=4) && (vida>0) && (dano>0) && (esquiva>0 && esquiva<1) && ((nivel>0) && (nivel<=3))){	/*ASSERTIVA EXECUTÁVEL DE ENTRADA: verifica a validade das informações enviadas(se estão dentro do intervalo aceito pelo jogo)*/
       85:  460:		if(!UnidadeVazia(lis)){	/*se a lista enviada não for nula, insere no fim*/
      189:  461:			while(aux->prox != NULL){/*enquanto o ponteiro de próximo em auxiliar não for nulo, continua com o laço. Objetivo: encontrar a última posição da lista*/
       63:  462:				aux = aux->prox;
        -:  463:			}
       63:  464:			aux->prox = novo;	/*ponteiro de próximo da última célula recebe o novo elemento*/
       63:  465:			novo->ant = aux;	/*ponteiro de anterior da célula inserida recebe o último elemento da lista exsitente*/
        -:  466:
       63:  467:			return lis;	/*retorna a lista atualizada*/
        -:  468:		} else{	/*se a lista enviada for nula, retorna a célula auxiliar*/
       22:  469:			novo->ant = NULL;	/*ponteiro de anterior da célula inserida recebe nulo já que é o único elemento da lista*/
       22:  470:			return novo;
        -:  471:		}
        -:  472:	}else{	/*se alguma informação enviada for inválida, retorna a lista sem fazer alterações*/
    #####:  473:		return lis;
        -:  474:	}
        -:  475:}
        -:  476:
        -:  477:/*	--------------------FUNÇÕES DE REMOÇÃO--------------------	*/
        -:  478:
        -:  479:/***************************************************************************/
        -:  480:/**
        -:  481:* \fn Unidade* RemoverUnidade(Unidade* lis, Unidade *retira)
        -:  482:*
        -:  483:* \brief Realiza a remoção do nó (personagem) específico que foi enviado para a função.
        -:  484:*
        -:  485:* @param lis - ponteiro para estrutura Unidade (lista de personagens).
        -:  486:* @param retira - ponteiro para o nó (personagem) específico a ser removido.
        -:  487:*
        -:  488:* \return Retorna a lista atualizada.
        -:  489:* 
        -:  490:* Assertiva de entrada
        -:  491:*
        -:  492:* A estrutura de Unidade que contém os personagens precisa ter sido declarada.
        -:  493:* A estrutura de Unidade que será removida precisa estar contida na lista enviada.
        -:  494:***************************************************************************/
        -:  495:
        -:  496:/*
        -:  497:Função responsável pela remoção de elementos em qualquer posição de uma lista.
        -:  498:REQUISITOS: Enviar um ponteiro de Unidade alocado em memória.
        -:  499:HIPÓTESES: A função deve retirar um elemento de uma lista duplamente encadeada. Se a lista for nula, não realiza operação alguma. Se a lista contiver apenas um ou mais elementos, remove o nó final.
        -:  500:ASSERTIVAS DE ENTRADA: A estrutura de unidade que contém a lista deve ter sido declarada e alocada, enquanto a estrutura a ser removida deve pertencer à lista.
        -:  501:ASSERTIVAS DE SAÍDA: Se a lista for vazia, retorna nulo, caso contrário, remove o elemento procurado e retorna a lista atualizada.
        -:  502:INTERFACE EXPLÍCITA: O tipo de saída Unidade* e os parâmetros de entrada Unidade* lis, Unidade *retira.
        -:  503:INTERFACE IMPLÍCITA: As variáveis auxiliares, a remoção do elemento na lista e as verificações de entrada e saída.
        -:  504:*/
        -:  505:
       39:  506:Unidade* RemoverUnidade(Unidade* lis, Unidade *retira){
       39:  507:	Unidade* aux = NULL;	/*ponteiro auxiliar do tipo Unidade recebe NULL*/
       39:  508:	Unidade* p = lis;	/*ponteiro auxiliar do tipo Unidade recebe a lista do parâmetro de entrada*/
        -:  509: 
       83:  510:	while(p!=retira && p != NULL)	/*o laço deve procurar pelo elemento a ser removido*/
        -:  511:	{
        5:  512:		aux = p;
        5:  513:	  	p = p->prox;
        -:  514:	}
       39:  515:	if(p==NULL)     /*se p é nulo, então a lista é vazia*/
        -:  516:	{ 
    #####:  517:		return lis;	/*retorna-se a lista vazia*/
        -:  518:	}
        -:  519:	  
       39:  520:	if(aux==NULL){ /*se aux for nulo, significa que o elemento a ser removido é o primeiro*/
       37:  521:		lis = p->prox; /*pega a segunda posição da lista*/
       37:  522:		if (p->prox!=NULL)
        -:  523:		   	{
       27:  524:		   		lis->ant = NULL;	/*seta o poneiro de anterior da segunda posição para nulo*/
        -:  525:		   	}
       37:  526:	   	free(p); /*libera a posição atual*/
       37:  527:	   	return lis;	/*retorna a lista atualizada*/
        -:  528:	}
        -:  529:	else	/*se aux é diferente de nulo, significa que o elemento está no meio ou fim da lista*/
        -:  530:	{
        2:  531:	   	aux->prox = p->prox; /*arruma o ponteiro da penúltima posição*/
        2:  532:	   	if (p->prox!=NULL)
        -:  533:	   	{
        1:  534:	   		p->prox->ant = aux;	/*rearranja o ponteiro de anterior da unidade à frentre*/
        -:  535:	   	}
        2:  536:	   	free(p); /*libera o último espaço de memória*/
        2:  537:	   	return lis;	/*retorna a lista atualizada*/
        -:  538:	}
        -:  539:}
        -:  540:
        -:  541:/***************************************************************************/
        -:  542:/**
        -:  543:* \fn Unidade* LimpaLista(Unidade* lis)
        -:  544:*
        -:  545:* \brief Realiza a limpeza de uma lista de personagens, removendo todos os seus nós.
        -:  546:*
        -:  547:* @param lis - ponteiro para a estrutura Unidade (lista de personagens).
        -:  548:*
        -:  549:* \return Retorna a lista sem nenhum nó com o valor NULL.
        -:  550:* 
        -:  551:* Assertiva de entrada
        -:  552:*
        -:  553:* A estrutura de Unidade enviada para a função precisa ser válida.
        -:  554:***************************************************************************/
        -:  555:
        -:  556:/*
        -:  557:Função que remove todos os elementos de uma lista.
        -:  558:REQUISITO: Enviar um ponteiro de Unidade devidamente alocado.
        -:  559:HIPÓTESE: A função deve receber um ponteiro de lista do tipo Unidade e remover todos os seus elementos.
        -:  560:ASSERTIVAS DE ENTRADA: Estrutura enviada para a função necessita ter sido declarada e alocada.
        -:  561:ASSERTIVAS DE SAÍDA: Não há.
        -:  562:INTERFACE EXPLÍCITA: O tipo de retorno Unidade* e a lista de entrada Unidade* lis.
        -:  563:INTERFACE IMPLÍCITA: As variáveis auxiliares e a remoção de todos os  elementos da lista.
        -:  564:*/
    #####:  565:Unidade* LimpaLista(Unidade* lis){
        -:  566:	Unidade* aux;	/*ponteiros auxiliares para percorrimento da lista*/
    #####:  567:	Unidade* p = lis;
    #####:  568:	while(p!=NULL)	/*enquanto o ponteiro nao for nulo, passa para a p´roximo posição da lista e libera a memória da anterior*/
        -:  569:	{
    #####:  570:		aux = p->prox;
    #####:  571:		free(p);
    #####:  572:		p=aux;
        -:  573:	}
    #####:  574:	return NULL;	/*retorna nulo*/
        -:  575:}
        -:  576:
        -:  577:/***************************************************************************/
        -:  578:/**
        -:  579:* \fn Unidade * RemoverUnidadeFinal (Unidade * lis)
        -:  580:*
        -:  581:* \brief Realiza a remoção do último nó (personagem) da lista de personagens.
        -:  582:*
        -:  583:* @param lis - ponteiro para a estrutura Unidade (lista de personagens).
        -:  584:*
        -:  585:* \return Retorna a lista atualizada.
        -:  586:* 
        -:  587:* Assertiva de entrada
        -:  588:*
        -:  589:* A estrutura de Unidade enviada para a função precisa ter sido declarada.
        -:  590:***************************************************************************/
        -:  591:
        -:  592:/*
        -:  593:Função de remoção no fim de uma lista.
        -:  594:REQUISITO: Ponteiro de Unidade declarado e devidamento alocado.
        -:  595:HIPÓTESE: A função deve remover a última célula de uma lista duplamente encadeada.
        -:  596:ASSERTIVAS DE ENTRADA: Estrutura enviada para a função necessita ter sido declarada e alocada.
        -:  597:ASSERTIVAS DE SAÍDA: Se a lista for vazia, retorna nulo, caso contrário, remove o elemento procurado e retorna a lista atualizada.
        -:  598:INTERFACE EXPLÍCITA: o tipo de retorno Unidade* e o parâmetros de entrada Unidade * lis.
        -:  599:INTERFACE IMPLÍCITA: Os ponteiros auxiliares e a operação de remoção.
        -:  600:*/
       38:  601:Unidade * RemoverUnidadeFinal (Unidade * lis){
       38:  602:	Unidade* aux = NULL;
       38:  603:	Unidade* p = lis;
        -:  604:	
       38:  605:	if(!UnidadeVazia(lis)){	/*verifica se a lista tem elementos*/
       38:  606:		if(p==NULL){	/*se p é nulo, então a lista é vazia(apenas para certificar)*/
    #####:  607:			return lis;
        -:  608:		}
        -:  609:
      130:  610:		while(p->prox!=NULL){	/*vai até o final da lista*/
       54:  611:			aux = p;
       54:  612:			p = p->prox;
        -:  613:		}
        -:  614:		
       38:  615:		if(aux==NULL){	/*se aux for nulo, significa que o elemento a ser removido é unico*/
       10:  616:			lis = p->prox;	/*pega a segunda posição da lista(nula)*/
       10:  617:			free(p);	/*libera a posição atual*/
       10:  618:			return lis;
        -:  619:		} else {
       28:  620:			aux->prox = p->prox;	/*arruma o ponteiro da penúltima posição*/
       28:  621:			free(p);	/*libera o último espaço de memória*/
       28:  622:			return lis;
        -:  623:		}
        -:  624:	} else {
    #####:  625:		return NULL;
        -:  626:	}
        -:  627:}
        -:  628:
        -:  629:/*	--------------------FUNÇÕES DE INICIALIZAÇÃO--------------------	*/
        -:  630:
        -:  631:/***************************************************************************/
        -:  632:/**
        -:  633:* \fn Edificio* InicializarEdificio(Edificio* E,int custounidade,int nivel)
        -:  634:*
        -:  635:* \brief Aloca a estrutura Edifício que pode representar no game um Quartel, Casa da Lanças ou Campo de Tiro.
        -:  636:*
        -:  637:* @param E - ponteiro para a estrutura Edificio.
        -:  638:* @param custounidade - valor inteiro que representa a taxa para a criação de uma unidade para aquele tipo de edifício.
        -:  639:* @param nivel - valor inteiro que representa o nível do edifício.
        -:  640:*
        -:  641:* \return Retorna a estrutura alocada.
        -:  642:* 
        -:  643:* Assertiva de entrada
        -:  644:*
        -:  645:* A estrutura de Edificio enviada para a função precisa ter sido declarada.
        -:  646:* Os tipos de cada parâmetros precisam estar de acordo com a função.
        -:  647:***************************************************************************/
        -:  648:
        -:  649:/*
        -:  650:Função de inicialização de Edificio.
        -:  651:REQUISITO: Enviar informações positivas.
        -:  652:HIPÓTESE: Caso o edificio não exista, a função deve alocar em memória um espaço e incializar os valores. Caso o edificio exista, os valores devem ser apenas atualizados.
        -:  653:ASSERTIVAS DE ENTRADA: Estrutura enviada para a função necessita ter sido declarada e alocada. Os valores numéricos devem respeitar seus tipos.
        -:  654:ASSERTIVAS DE SAÍDA: Caso os valores enviados nos parâmetros estejam dentro do intervalo imposto pela verificação, retorna-se a estrutura "novo" com valores inicializados, caso contrário, retorna a estrutura original(enviada no parâmetro) sem realizar alterações.
        -:  655:INTERFACE EXPLÍCITA: O tipo de retorno Edificio* e os parâmetros de entrada Edificio* E,int custounidade,int nivel.
        -:  656:INTERFACE IMPLÍCITA: As assertivas, o ponteiro auxiliar de "novo" e as operações com ponteiro.
        -:  657:*/
        6:  658:Edificio* InicializarEdificio(Edificio* E,int custounidade,int nivel){
        -:  659:	Edificio* novo;	/*declaração de uma estrutura auxiliar chamada "novo"*/
        6:  660:	if(EdificioVazia(E)){	/*se edificio não existir, aloca um espaço de memória*/
        6:  661:		novo = (Edificio*)malloc(sizeof(Edificio));
        -:  662:	}else{	/*caso exista, passa o ponteiro para a estrutura auxiliar*/
    #####:  663:		novo = E;
        -:  664:	}
        -:  665:	
        6:  666:	if((custounidade>0) && ((nivel>0) && (nivel<=3))){	/*verifica a validade das informações enviadas*/
        6:  667:		novo->custounidade = custounidade;
        6:  668:		novo->nivel = nivel;
        -:  669:		
        6:  670:		return novo;
        -:  671:	}else{
    #####:  672:		return novo;/*se alguma informação enviada for inválida, retorna o ponteiro sem fazer alterações*/
        -:  673:	}
        -:  674:}
        -:  675:
        -:  676:/***************************************************************************/
        -:  677:/**
        -:  678:* \fn Comercio* InicializarComercio(Comercio* C,int taxaouro,int nivel)
        -:  679:*
        -:  680:* \brief Aloca a estrutura Comercio com os devidos atributos.
        -:  681:*
        -:  682:* @param C - ponteiro para a estrutura Comercio.
        -:  683:* @param taxaouro - valor inteiro que representa a quantidade de ouro gerada por wave no game.
        -:  684:* @param nivel - valor inteiro que representa o nível do edifício Comércio.
        -:  685:*
        -:  686:* \return Retorna a estrutura alocada.
        -:  687:* 
        -:  688:* Assertiva de entrada
        -:  689:*
        -:  690:* A estrutura de Comercio enviada para a função precisa ser válida.
        -:  691:* Os tipos dos parâmetros precisam ser obedecidos.
        -:  692:***************************************************************************/
        -:  693:
        -:  694:/*
        -:  695:Função de inicialização de Comercio.
        -:  696:REQUISITO: Comercio ter sido alocado e enviar informações positivas.
        -:  697:HIPÓTESE: Caso o comercio não exista, a função deve alocar em memória um espaço e incializar os valores. Caso o comercio exista, os valores devem ser apenas atualizados.
        -:  698:ASSERTIVA DE ENTRADA: Estrutura enviada para a função necessita ter sido declarada e alocada. Os valores numéricos devem estar de acordo com seus tipos.
        -:  699:ASSERTIVAS DE SAÍDA: Caso as informações estejam dentro do intervalo especificado pelo jogo, retorna-se o ponteiro de "novo" com os valores atualizados ,caso contrário, retorna-se o ponteiro enviado como parâmetro sem alterações.
        -:  700:INTERFACE EXPLÍCITA: O tipo de retorno Comercio* e os parâmetros de entrada Comercio* C,int taxaouro,int nivel.
        -:  701:INTERFACE IMPLÍCITA: As assertivas, o ponteiro auxiliar de "novo" e as operações.
        -:  702:*/
        2:  703:Comercio* InicializarComercio(Comercio* C,int taxaouro,int nivel){
        -:  704:	Comercio* novo;
        2:  705:	if(ComercioVazia(C)){	/*se comercio não existir, aloca um espaço de memória e atribui o tempo de geração de recursos*/
        2:  706:		novo = (Comercio*)malloc(sizeof(Comercio));
        -:  707:	}else{
    #####:  708:		novo = C;
        -:  709:	}
        -:  710:	
        2:  711:	if((taxaouro>0) && ((nivel>0) && (nivel<=3))){	/*verifica a validade das informações enviadas*/
        2:  712:		novo->taxaouro = taxaouro;
        2:  713:		novo->nivel = nivel;
        -:  714:		
        2:  715:		return novo;
        -:  716:	}else{
    #####:  717:		return novo;/*se alguma informação enviada for inválida, retorna o ponteiro sem fazer alterações*/
        -:  718:	}
        -:  719:}
        -:  720:
        -:  721:/*	--------------------FUNÇÕES DE VERIFICAÇÃO--------------------	*/
        -:  722:
        -:  723:/***************************************************************************/
        -:  724:/**
        -:  725:* \fn int VerificarCastelo(Castelo* C)
        -:  726:*
        -:  727:* \brief Verifica se cada edifício da estrutura Castelo é nulo ou não.
        -:  728:*
        -:  729:* @param C - ponteiro para a estrutura que contém os edifícios
        -:  730:*
        -:  731:* \return Retorna o valor inteiro 1 caso todos os edifícios não sejam nulos, ou 0 caso algum deles seja.
        -:  732:* 
        -:  733:* Assertiva de entrada
        -:  734:*
        -:  735:* A estrutura enviada para a função precisa ter sido declarada para que a análise funcione corretamente.
        -:  736:***************************************************************************/
        -:  737:
        -:  738:/*
        -:  739:Função de verificação de Castelo.
        -:  740:REQUISITO: Enviar ponteiro de Castelo alocado.
        -:  741:HIPÓTESE: A função deve verificar os apontamentos de edificio e comercio em Castelo, certificando que sejam diferentes de nulo. Caso passe no teste, retorna 1, caso contrário, retorna 0.
        -:  742:ASSERTIVAS DE ENTRADA: Estrutura enviada para a função necessita ter sido declarada e alocada.
        -:  743:ASSERTIVAS DE SAÍDA: Caso todas as estruturas sejam diferentes de nulo, retorna-se 1, caso contrário, retorna-se 0.
        -:  744:INTERFACE EXPLÍCITA: O tipo de retorno int e o parâmetro de entrada Castelo* C.
        -:  745:INTERFACE IMPLÍCITA: A verificação de retorno 0 ou 1.
        -:  746:*/
        3:  747:int VerificarCastelo(Castelo* C){
        3:  748:	if((!EdificioVazia(C->quartel)) && (!EdificioVazia(C->campodetiro)) && (!EdificioVazia(C->casadaslancas)) && (!ComercioVazia(C->comercio))){
        2:  749:		return 1;
        -:  750:	}else{
        1:  751:		return 0;
        -:  752:	}
        -:  753:}
        -:  754:
        -:  755:/***************************************************************************/
        -:  756:/**
        -:  757:* \fn int VerificarCabecaGeral(CabecaGeral* CG)
        -:  758:*
        -:  759:* \brief Verifica se as estruturas internas do controlador são nulas ou não.
        -:  760:*
        -:  761:* @param CG - ponteiro para a estrutura controladora
        -:  762:*
        -:  763:* \return Retorna o valor inteiro 1 caso as suas estruturas não sejam nulas, ou 0 caso as estruturas sejam nulas.
        -:  764:* 
        -:  765:* Assertiva de entrada
        -:  766:*
        -:  767:* A estrutura controladora precisa ter sido declarada.
        -:  768:***************************************************************************/
        -:  769:
        -:  770:/*
        -:  771:Função de verificação de CabecaGeral.
        -:  772:REQUISITO: Enviar ponteiro de CabecaGeral alocado.
        -:  773:HIPÓTESE: A função deve verificar os apontamentos de castle e character em CabecaGeral, certificando que sejam diferentes de nulo. Caso passe no teste, retorna 1, caso contrário, retorna 0.
        -:  774:ASSERTIVAS DE ENTRADA: A estrutura controladora necessita ter sido declarada e alocada.
        -:  775:ASSERTIVAS DE SAÍDA:  Caso todas as estruturas sejam diferentes de nulo, retorna-se 1, caso contrário, retorna-se 0.
        -:  776:INTERFACE EXPLÍCITA: O tipo de retorno int e o parâmetro de entrada CabecaGeral* CG.
        -:  777:INTERFACE IMPLÍCITA: A verificação de retorno 0 ou 1.
        -:  778:*/
        3:  779:int VerificarCabecaGeral(CabecaGeral* CG){
        3:  780:	if((!CasteloVazia(CG->castle)) && (!CabecaPFilasVazia(CG->character))){
        3:  781:		return 1;
        -:  782:	}else{
    #####:  783:		return 0;
        -:  784:	}
        -:  785:}
        -:  786:
        -:  787:/***************************************************************************/
        -:  788:/**
        -:  789:* \fn int VerificaEstrutura (Unidade * lista)
        -:  790:*
        -:  791:* \brief Assertiva estrutural para garantir que a estrutura de lista duplamente encadeada foi implementada corretamente.
        -:  792:*
        -:  793:* @param lista - ponteiro para a estrutura Unidade (lista de personagens).
        -:  794:*
        -:  795:* \return Retorna o valor inteiro 1 caso a estrutura esteja correta, ou 0 caso contrário.
        -:  796:* 
        -:  797:* Assertiva de entrada
        -:  798:*
        -:  799:* A estrutura de Unidade enviada para a função precisa ter sido declarada.
        -:  800:***************************************************************************/
        -:  801:
        -:  802:/*
        -:  803:Função de verificação para filas.
        -:  804:REQUISITO: Enviar ponteiro de Unidade alocado.
        -:  805:HIPÓTESE: A função deve verificar se os apontamentos de próximo e anterior das filas de Unidade estão feitos de forma correta.
        -:  806:ASSERTIVAS DE ENTRADA: Estrutura enviada para a função necessita ter sido declarada e alocada.
        -:  807:ASSERTIVAS DE SAÍDA:  Caso todas a estruturas seja diferentes de nulo e o apontamento da lista esteja correto, retorna-se 1, caso contrário, retorna-se 0.
        -:  808:INTERFACE EXPLÍCITA: O tipo de retorno int e o parâmetro de entrada Unidade* lista.
        -:  809:INTERFACE IMPLÍCITA: As assertivas, os ponteiros auxiliares e as operações.
        -:  810:*/
    #####:  811:int VerificaEstrutura (Unidade * lista) {
    #####:  812:	Unidade* t = NULL;
    #####:  813:	Unidade* q = NULL;
    #####:  814:	int v = 0;
        -:  815:
    #####:  816:	if(!UnidadeVazia(lista)){	/*Verifica se a lista está vazia*/
    #####:  817:		for (t = lista; t != NULL; t = t->prox) {	/*Estrutura de repetição contada para varrer o polinômio do começo até o fim*/
    #####:  818:			if (t->prox != NULL) {
    #####:  819:				if (t->prox->ant == t) {	/*Verifica se o prox->ant é igual a ele mesmo*/
    #####:  820:					v = 1;	/*Se for, a variável de retorno recebe 1*/
        -:  821:				}else{
    #####:  822:					v = 0;	/*Caso contrário, recebe 0*/
        -:  823:				}
        -:  824:			}
        -:  825:		}
        -:  826:
    #####:  827:		t = lista;
    #####:  828:		while(t->prox != NULL){/*Vai até o fim da fila*/
    #####:  829:			t = t->prox;
        -:  830:		}
        -:  831:
    #####:  832:		for(q = t; q != NULL; q = q->ant){	/*Estrutura de repetição contada para varrer o polinômio do final até o início*/
    #####:  833:			if(q->ant != NULL){
    #####:  834:				if(q->ant->prox == q){	/*Verifica se o ant->prox é igual a ele mesmo*/
    #####:  835:					v = 1;	/*Se for, a variável de retorno recebe 1*/
        -:  836:				}else{
    #####:  837:					v = 0;	/*Caso contrário, recebe 0*/
        -:  838:				}
        -:  839:			}
        -:  840:		}
        -:  841:	}else{
    #####:  842:		v = 0;
        -:  843:	}
        -:  844:	
    #####:  845:	return v;
        -:  846:}
        -:  847:
        -:  848:/*	--------------------FUNÇÕES DE ATUALIZAÇÃO--------------------	*/
        -:  849:
        -:  850:/***************************************************************************/
        -:  851:/**
        -:  852:* \fn Castelo* AtualizarCasteloOuro(Castelo* C, int ouro)
        -:  853:*
        -:  854:* \brief Atualiza a quantidade de ouro (recurso) do castelo do game.
        -:  855:*
        -:  856:* @param C - ponteiro para a estrutura de Castelo do game.
        -:  857:* @param ouro - valor inteiro que representa a quantidade de ouro a ser adicionada ou removida do Castelo.
        -:  858:*
        -:  859:* \return Retorna a estrutura de Castelo com a quantidade de ouro atualizada.
        -:  860:* 
        -:  861:* Assertiva de entrada
        -:  862:*
        -:  863:* A estrutura de Castelo enviada precisa ter sido declarada.
        -:  864:* A quantidade de ouro precisa ser um valor inteiro.
        -:  865:***************************************************************************/
        -:  866:
        -:  867:/*
        -:  868:Função de atualização do ouro do Castelo.
        -:  869:REQUISITO: Enviar ponteiro de Castelo alocado e valor de ouro maior ou igual a zero.
        -:  870:HIPÓTESE: A função deve atualizar os valores de ouro do Castelo.
        -:  871:ASSERTIVAS DE ENTRADA: Estrutura enviada para a função necessita ter sido declarada e alocada. O valor de ouro deve ser inteiro.
        -:  872:ASSERTIVAS DE SAÍDA: Se a soma/subtração for positiva, retorna o ponteiro de castelo com o valor do ouro atualizado, caso contrário, retorna o castelo sem efetuar operações.
        -:  873:INTERFACE EXPLÍCITA: O tipo de retorno Castelo* e os parâmetros de entrada Castelo* C, int ouro.
        -:  874:INTERFACE IMPLÍCITA: Os ponteiros auxiliares, a verificação das informações e a soma/subtração.
        -:  875:*/
       44:  876:Castelo* AtualizarCasteloOuro(Castelo* C, int ouro){
        -:  877:	Castelo* novo;	/*ponteiro auxiliar do tipo castelo*/
       44:  878:	novo = C;	/*novo recebe o ponteiro de castelo*/
        -:  879:	
       44:  880:	if ((novo->ouro + (ouro)) >= 0) {	/*ASSERTIVA EXECUTÁVEL DE ENTRADA: verifica a validade das informações enviadas(se o valor permanece positivo)*/
       44:  881:		novo->ouro = novo->ouro + (ouro);	/*soma/subtrai o valor original do valor enviado*/
       44:  882:		return novo;
        -:  883:	} else {	/*caso o valor se torne negativo, não realiza operação alguma e retorna o ponteiro do castelo*/
    #####:  884:		return C;
        -:  885:	}
        -:  886:}
